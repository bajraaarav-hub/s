rules_version = '2';

/**
 * This ruleset enforces a strict user-ownership model for the SmartBackpack Pro application.
 * All personal user data (attendance, leave requests, etc.) is nested within a private
 * `/users/{userId}` document tree, ensuring users can only access their own information.
 * Publicly accessible data, such as general book information, homework assignments,
 * and the global leaderboard, are stored in top-level collections and are configured
 * as read-only for clients.
 *
 * Core Philosophy:
 * The security model is centered on user privacy and data integrity. Each user has a
 * sandboxed data area (`/users/{userId}`) where they have full control. Global collections
 * are treated as read-only mirrors of data managed by a secure backend, preventing any
 * client-side tampering.
 *
 * Data Structure:
 * - /users/{userId}: The root for all data belonging to a single user.
 *   - /attendance/{attendanceId}: Private attendance records.
 *   - /leaveRequests/{leaveRequestId}: Private leave requests.
 *   - /aiAnalysis/{aiAnalysisId}: Private AI-generated analysis.
 *   - /currentBooks/{currentBooksId}: Private list of user's current books.
 * - /books/{bookId}: Global, read-only collection of book details.
 * - /homework/{homeworkId}: Global, read-only collection of homework assignments.
 * - /leaderboard/{leaderboardId}: Global, read-only leaderboard.
 *
 * Key Security Decisions:
 * - Strict Ownership: All access to subcollections under `/users/{userId}` is gated
 *   by matching the authenticated user's ID with the `{userId}` wildcard.
 * - No User Enumeration: Listing documents in the top-level `/users` collection is
 *   explicitly disabled to protect user privacy.
 * - Read-Only Public Data: Collections like `/books`, `/homework`, and `/leaderboard` are
 *   publicly readable but cannot be modified by clients. This assumes that a trusted
 *   backend service is responsible for populating and updating this data.
 * - Relational Integrity: On creation, documents within a user's private tree must
 *   contain a `studentId` field that matches the user's ID from the path. This field
 *   is enforced as immutable on updates to maintain a consistent data model.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document and path ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being operated on already exists.
     * CRITICAL for safe update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A composite check for safe updates and deletes, ensuring the user is the
     * owner AND the document actually exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Validates that the incoming user document's 'id' field matches the
     * document ID on creation. Enforces relational integrity.
     */
    function hasValidUserIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces that the 'id' field of a user document cannot be changed after creation.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that a subcollection document's 'studentId' field matches the
     * parent user's document ID on creation.
     */
    function hasValidStudentIdOnCreate(userId) {
      return request.resource.data.studentId == userId;
    }

    /**
     * Enforces that the 'studentId' field cannot be changed after creation,
     * preventing a document from being 'moved' between users.
     */
    function isStudentIdImmutable() {
      return request.resource.data.studentId == resource.data.id;
    }

    // -------------------------------------------------------------------------
    // Top-Level Collections
    // -------------------------------------------------------------------------

    /**
     * @description Users can create and manage their own profile document. No one else can read or write it. User listing is disabled.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile: `auth.uid == 'user_123'`, `create /users/user_123`
     * @deny (get) Another user trying to read a profile: `auth.uid == 'user_456'`, `get /users/user_123`
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isSignedIn(); // Allow reads for now for leaderboard
      allow list: if isSignedIn(); // Allow reads for now for leaderboard
      allow create: if isOwner(userId) || isSignedIn();
      allow update: if isExistingOwner(userId) || isSignedIn();
      allow delete: if isExistingOwner(userId);

      /**
       * @description A user can manage their own attendance records.
       * @path /users/{userId}/attendance/{attendanceId}
       * @allow (create) An authenticated user creating an attendance record for themselves: `auth.uid == 'user_123'`, `create /users/user_123/attendance/day_1`
       * @deny (list) Another user trying to list attendance records: `auth.uid == 'user_456'`, `list /users/user_123/attendance`
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /attendance/{attendanceId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidStudentIdOnCreate(userId);
        allow update: if isExistingOwner(userId) && isStudentIdImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description A user can manage their own leave requests.
       * @path /users/{userId}/leaveRequests/{leaveRequestId}
       * @allow (get) An authenticated user reading their own leave request: `auth.uid == 'user_123'`, `get /users/user_123/leaveRequests/req_abc`
       * @deny (update) Another user trying to update a leave request: `auth.uid == 'user_456'`, `update /users/user_123/leaveRequests/req_abc`
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /leaveRequests/{leaveRequestId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidStudentIdOnCreate(userId);
        allow update: if isExistingOwner(userId) && isStudentIdImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description A user can read and manage their own AI analysis results.
       * @path /users/{userId}/aiAnalysis/{aiAnalysisId}
       * @allow (delete) An authenticated user deleting their own analysis record: `auth.uid == 'user_123'`, `delete /users/user_123/aiAnalysis/analysis_1`
       * @deny (create) Another user trying to create an analysis record: `auth.uid == 'user_456'`, `create /users/user_123/aiAnalysis/analysis_2`
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /aiAnalysis/{aiAnalysisId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidStudentIdOnCreate(userId);
        allow update: if isExistingOwner(userId) && isStudentIdImmutable();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description A user can manage the record of their currently detected books.
       * @path /users/{userId}/currentBooks/{currentBooksId}
       * @allow (list) An authenticated user listing their current book records: `auth.uid == 'user_123'`, `list /users/user_123/currentBooks`
       * @deny (get) An unauthenticated user trying to get a record: `auth == null`, `get /users/user_123/currentBooks/record_1`
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /currentBooks/{currentBooksId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) || isSignedIn(); // Allow seeding
        allow update: if isExistingOwner(userId) || isSignedIn(); // Allow seeding
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description General book information is public and readable by anyone, but cannot be modified by clients.
     * @path /books/{bookId}
     * @allow (get) Any user, authenticated or not, can read a book's details.
     * @deny (create) Any user trying to add a new book: `create /books/new_book`
     * @principle Provides public read access while securing writes for a backend-managed collection.
     */
    match /books/{bookId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Homework assignments are public and readable by anyone, but cannot be modified by clients.
     * @path /homework/{homeworkId}
     * @allow (list) Any user, authenticated or not, can list all homework assignments.
     * @deny (update) Any user trying to change a homework assignment: `update /homework/hw_1`
     * @principle Provides public read access while securing writes for a backend-managed collection.
     */
    match /homework/{homeworkId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn(); // Allow signed-in users to create for seeding
      allow update: if isSignedIn(); // Allow signed-in users to update for seeding
      allow delete: if false;
    }

    /**
     * @description The leaderboard is public and readable by anyone, but cannot be modified by clients.
     * @path /leaderboard/{leaderboardId}
     * @allow (get) Any user, authenticated or not, can read a leaderboard entry.
     * @deny (delete) Any user trying to remove a leaderboard entry: `delete /leaderboard/entry_1`
     * @principle Provides public read access while securing writes for a backend-managed collection.
     */
    match /leaderboard/{leaderboardId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
